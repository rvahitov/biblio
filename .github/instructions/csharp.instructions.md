---
applyTo: '**/*.cs'
---
## Стиль кодирования

### Общие принципы
- Используй неизменяемые типы данных (immutable)
- Предпочитай функциональные конструкции
- Избегай null, используй Option/Maybe паттерны
- Применяй принципы SOLID и функционального программирования

### Именование
- **Классы**: PascalCase (например, `BookService`, `UserRepository`)
- **Методы**: PascalCase (например, `GetBook`, `CreateUser`)
- **Переменные**: camelCase (например, `bookId`, `userName`)
- **Константы**: UPPER_SNAKE_CASE (например, `MAX_BOOKS_COUNT`)
- **Интерфейсы**: Префикс `I` (например, `IBookService`, `IMessage`)

### Функциональные паттерны
- Используй функторы, монады и аппликативы из библиотеки LanguageEx
- Предпочитай композицию функций вместо наследования
- Используй паттерн Either для обработки ошибок
- Применяй неизменяемые коллекции

## Файловая организация
- Один публичный класс на файл
- Имя файла должно соответствовать имени класса
- Группируй связанные классы в папки по доменам
- Выделяй интерфейсы в отдельные файлы

## Комментарии и документация
- Используй XML-документацию для публичных API
- Добавляй комментарии для сложной бизнес-логики
- Объясняй математические концепции из теории категорий
- Документируй функциональные композиции

### XML документация на русском языке

#### Общие принципы
- Вся XML документация должна быть на русском языке
- Используй краткие, но информативные описания
- Объясняй назначение параметров и возвращаемых значений
- Указывай возможные исключения

#### Обязательные теги
```csharp
/// <summary>
/// Краткое описание назначения класса/метода
/// </summary>
/// <param name="parameterName">Описание параметра</param>
/// <returns>Описание возвращаемого значения</returns>
/// <exception cref="ExceptionType">Условие возникновения исключения</exception>
```

#### Примеры XML документации

##### Для классов
```csharp
/// <summary>
/// Представляет сервис для работы с книгами в библиотечной системе.
/// Обеспечивает функциональную обработку операций CRUD с использованием монадических паттернов.
/// </summary>
public class BookService
```

##### Для методов
```csharp
/// <summary>
/// Получает книгу по её идентификатору с функциональной обработкой ошибок.
/// </summary>
/// <param name="bookId">Уникальный идентификатор книги</param>
/// <returns>Either с ошибкой или найденной книгой</returns>
/// <exception cref="ArgumentNullException">Если bookId равен null</exception>
public Either<BookNotFoundError, Book> GetBook(BookId bookId)
```

##### Для интерфейсов функционального программирования
```csharp
/// <summary>
/// Определяет функтор - контейнер, к значениям которого можно применять функции.
/// Это базовая абстракция теории категорий для функционального программирования.
/// </summary>
/// <typeparam name="T">Тип значения в контексте функтора</typeparam>
public interface IFunctor<T>
{
    /// <summary>
    /// Применяет функцию к значению внутри функтора, сохраняя структуру контейнера.
    /// Это основная операция функтора, также известная как fmap в теории категорий.
    /// </summary>
    /// <typeparam name="TResult">Тип результата применения функции</typeparam>
    /// <param name="func">Функция для применения к значению</param>
    /// <returns>Новый функтор с преобразованным значением</returns>
    IFunctor<TResult> Map<TResult>(Func<T, TResult> func);
}
```

##### Для record типов
```csharp
/// <summary>
/// Представляет неизменяемый идентификатор книги.
/// Обеспечивает типобезопасность и предотвращает путаницу с другими GUID значениями.
/// </summary>
/// <param name="Value">Уникальное значение идентификатора</param>
public record BookId(Guid Value);
```

#### Специальные теги для функционального программирования
```csharp
/// <remarks>
/// Этот метод следует законам функторов:
/// 1. Сохранение идентичности: Map(x => x) == исходный функтор
/// 2. Композиция: Map(f).Map(g) == Map(x => g(f(x)))
/// </remarks>
```

## Примеры паттернов

### Неизменяемые типы данных
```csharp
public record Book(BookId Id, string Title, AuthorId AuthorId, DateTime PublishedAt);
public record BookId(Guid Value);
```

### Функциональная обработка ошибок
```csharp
public Either<Error, Book> GetBook(BookId id) =>
    bookRepository.Find(id)
        .ToEither(() => new BookNotFoundError(id));
```

### Использование функторов
```csharp
public IFunctor<string> ProcessBookTitle(IFunctor<Book> bookFunctor) =>
    bookFunctor.Map(book => book.Title.ToUpperInvariant());
```
